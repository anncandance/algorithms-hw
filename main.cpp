#include <iostream>
#include"G.h"
#include"G.cpp"

// алгоритм Косарайю
// запускаем DFS на графе g, сортируем вершины по времени выхода(= массив tout), берем позднейшую (:=v)
// в транспонированном графе gt в нее не входят ребра, поэтому DFS на gt от v пройдет по компоненте связности
// двигаемся таким образом по tout, сохраняем информацию о компонентах(вершины и соединения)
// строим граф на компонентах, транспонируем

int main() {
    // ввод графа через корректировку списка l
    initializer_list <std::initializer_list <int> > l =  {{1, 2}, {3}, {4}, {4}, {1}};
    G* graph  = new G(l);
    vector<int> tout = graph -> DFS();
    G t_graph = graph -> trans();
    t_graph.condensate(tout);
    return 0;
}


// тест (0-корень):{{1, 2, 3}, {4, 5}, {6}, {}, {}, {}, {}} ==> 0: 1, 2 ; 1:; , 2: 3 ; 3:;
// нумерация вершин графа конденсации не связана с исходной, поэтому
// оставляю также вывод компонент связности(перед выводом графа)
// вывод может содержать кратные ребра : {{1, 2}, {3}, {4}, {4}, {1}} ==> 0: 1, 1 ; 1:;
// тест {{}, {0,2}, {1}, {2}} ==> 0: 1 ; 1: 2 ; 2:;