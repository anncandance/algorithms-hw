#include <iostream>
#include <string>
using namespace std ;


// префикс-функция, возвращает указатель на массив длины = длине принимаемой строки //

int* prefix(string s) {
    int n = s.size(), i;
    int *p;
    p = new int[n];
    for(i=0; i<n; ++i) p[i]=0;
    for (i=1; i < n; ++i) {
        int j = p[i - 1];
        while ((j > 0) && (s[i] != s[j])) {
            j = p[j - 1]; }
        if (s[i] == s[j]) ++j;
        p[i] = j;
    }
    return p;
    }


// возвращает значение минимального периода принимаемой строки,
// принцип: зная мин и макс период подстроки s[:i], увеличиваем i в 2 раза +1 и смотрим в префикс-функцию
// если что-то сломалось и p[i]!=k(где k=макс период), находим индекс правого 0 в префикс-функции(= j), принимаем за новый период
// остается проверить "хвост", если длина строки не степень 2: его длина должна быть кратна мин периоду,
// а p[s.size()-1]>=макс периода

int min_period(string s){
    unsigned int i=1, k=1, mink=1, j=0;         // k-максимальный период, i-позиция, j=i до увеличения
    int *p = prefix(s);
    while(i<s.size()){
        if (p[i]>=k) {j=i; k*=2; i=i*2+1;} 
        else
        for(j=i; j>i/2; --j) if (p[j]==0) {mink = j+1; k=j+1; i=2*k-1; break;}
       }
    //j=k;
    if ((j<s.size()-1))
    {
        if (((s.size()-1-j)%mink==0)&&(p[s.size()-1]>=k)) return mink;
        mink=s.size();
    };
    return mink;
}

int main() {
    string s;
    cout<<"введите строку";
    cin>>s;
    cout<<min_period(s);
    return 0;
}
